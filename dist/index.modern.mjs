import e from"util";import t from"amqplib";import{cleanEnv as s,str as o,port as n}from"envalid";require("dotenv").config();class i{constructor(t){this.user=void 0,this.password=void 0,this.host=void 0,this.port=void 0,this.vhost=void 0,this.url=void 0,this.channel=void 0,this.canUseEnvConfig(t)?s(process.env,{RABBITMQ_HOST:o(),RABBITMQ_PASSWORD:o(),RABBITMQ_PORT:n({default:5672}),RABBITMQ_USER:o(),RABBITMQ_VHOST:o()}):(this.user=t.user,this.password=t.password,this.host=t.host,this.port=t.port,this.vhost=t.vhost),this.url=e.format("amqp://%s:%s@%s:%s/%s",this.user||process.env.RABBITMQ_USER,this.password||process.env.RABBITMQ_PASSWORD,this.host||process.env.RABBITMQ_HOST,this.port||process.env.RABBITMQ_PORT,this.vhost||process.env.RABBITMQ_VHOST),this.connect(this.url).then(e=>{this.channel=e})}getChannel(){return this.channel}canUseEnvConfig(e){return void 0!==e.useEnvironmentConfig}async connect(e){const s=await t.connect(e);return await s.createChannel()}async send(e){try{if(this.channel){console.log("[Data]",e),this.channel.assertQueue(e.queue,{durable:!0});const t=this.channel.sendToQueue(e.queue,Buffer.from(JSON.stringify(e.data)));console.log("[MQ Status]",t),console.log(" [x] Sent %s",e.data)}}catch(e){console.log(e)}}async onReceive(e){this.connect(this.url).then(()=>{setTimeout(()=>{this.listen(e)},500)})}listen({queue:e,callback:t}){try{this.channel.assertQueue(e),this.channel.consume(e,e=>{console.log("[x] receiving messages"),this.channel.ack(e),t(e)})}catch(e){console.log(e)}}}class a extends i{}var r;r=a,[class extends i{sendEmail({data:e,queue:t="email_notification"}){this.send({data:e,queue:t})}},class extends i{createNotification({data:e,queue:t="event_notification"}){this.send({data:e,queue:t})}}].forEach(e=>{Object.getOwnPropertyNames(e.prototype).forEach(t=>{Object.defineProperty(r.prototype,t,Object.getOwnPropertyDescriptor(e.prototype,t))})});export{a as default};
