import e from"util";import s from"amqplib";import{cleanEnv as t,str as o,port as n}from"envalid";require("dotenv").config();class i{constructor(s){this.user=void 0,this.password=void 0,this.host=void 0,this.port=void 0,this.vhost=void 0,this.url=void 0,this.channel=void 0,this.canUseEnvConfig(s)?t(process.env,{RABBITMQ_HOST:o(),RABBITMQ_PASSWORD:o(),RABBITMQ_PORT:n({default:5672}),RABBITMQ_USER:o(),RABBITMQ_VHOST:o()}):(this.user=s.user,this.password=s.password,this.host=s.host,this.port=s.port,this.vhost=s.vhost),this.url=e.format("amqp://%s:%s@%s:%s/%s",this.user||process.env.RABBITMQ_USER,this.password||process.env.RABBITMQ_PASSWORD,this.host||process.env.RABBITMQ_HOST,this.port||process.env.RABBITMQ_PORT,this.vhost||process.env.RABBITMQ_VHOST),this.connect(this.url).then(e=>{this.channel=e})}canUseEnvConfig(e){return void 0!==e.useEnvironmentConfig}async connect(e){const t=await s.connect(e);return await t.createChannel()}async send(e){try{console.log("[Data]",e),this.channel.assertQueue(e.queue,{durable:!0});const s=this.channel.sendToQueue(e.queue,Buffer.from(JSON.stringify(e.data)));console.log("[MQ Status]",s),console.log(" [x] Sent %s",e.data)}catch(e){console.log(e)}}async onReceive({queue:e}){var s;return this.channel&&(null==(s=this.channel)||s.assertQueue(e,{durable:!0}),this.channel.consume(e,e=>(console.log(e),console.log("[x] receiving messages"),this.channel.ack(e),new Promise(s=>s(e))))),null}}class a extends i{}var r;r=a,[class extends i{sendEmail({data:e,queue:s="email_notification"}){this.send({data:e,queue:s})}},class extends i{createNotification({data:e,queue:s="event_notification"}){this.send({data:e,queue:s})}}].forEach(e=>{Object.getOwnPropertyNames(e.prototype).forEach(s=>{Object.defineProperty(r.prototype,s,Object.getOwnPropertyDescriptor(e.prototype,s))})});export{a as default};
